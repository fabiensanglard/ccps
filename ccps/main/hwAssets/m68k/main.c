#include "ccps_gfx.h" // Contains all GFX data structures
#include "gfx.h" // This is auto-generated by GFX assets
#include "cpsa.h" // This is auto-generated
#include "cpsb.h" // This is auto-gemerated

// https://gcc.gnu.org/onlinedocs/gcc-3.2/gcc/Variable-Attributes.html
// https://ftp.gnu.org/old-gnu/Manuals/ld-2.9.1/html_chapter/ld_3.html
// https://mcuoneclipse.com/2016/11/01/getting-the-memory-range-of-sections-with-gnu-linker-files/

#define GFXRAM   __attribute__ ((section (".gfx_data")))

#define CPSA_REG __attribute__ ((section (".cpsa_reg")))  
#define CPSB_REG __attribute__ ((section (".cpsb_reg")))  


#define	MAXSPRITES	256
typedef struct {
	WORD	x;			// Sprite x position
	WORD	y;			// Sprite y position
	WORD	tile;		// Sprite tile

	// 0..4 CB[0..4] Palette ID used to render the tile
   // 5 X Flip Mirrored horizontally
   // 6 Y Flip Mirrored vertically
   // 7 LOOKUP Looks up the CB value into the RAM for each tile (see later section)
   // 8..11 XB[0..3] Horizontal size in tiles
   // 12..15 YB[0..3] Vertical size in tiles
	WORD	attributes;   	// Sprite attribute
} Sprite;

// TODO __attribute__ ((aligned (0xFF))) ?
GFXRAM Sprite sprites [MAXSPRITES]  =  {};


// TODO allow multpiple pages, right now there is only
//      enough space for one page (we need 6 for obj, scr1,2,3, and star1,2)
// TODO __attribute__ ((aligned ( 0x400))) ?
GFXRAM Palette palettes[32];

CPSA_REG WORD cpsa_reg[0x20] = {};
CPSB_REG WORD cpsb_reg[0x20] = {};


unsigned int vsyncCounter = 0;
unsigned int soundCounter = 0;


static const Palette ryu = {0xF111 ,0xFFD9,0xFFB8,0xFE97,0xFC86,0xF965,0xF643,0xFb00,
   	                   0xFfff,0xFeec,0xFdca,0xFba8,0xFa87,0xF765,0xFf00,0x0000};

void setPalette(int page, int paletteID, const Palette* palette) {

   for (int j = 0 ; j < 16 ; j++) {
  	  palettes[paletteID].colors[j] = (*palette).colors[j];
   }

   // Request upload palette page to sprites
   cpsb_reg[CPSB_REG_PALETTE_CONTROL] =  1;

   // Set palette base
   cpsa_reg[CPSA_REG_PALETTE_BASE] = (WORD)(((DWORD)palettes) >> 8);
}

//void drawRyu() {
//   setPalette(0, 2, &ryu);
//   Sprite* s = &sprites[0];
//   s->x = 220;
//   s->y = 100;
//   s->tile = 	4;
//   s->attributes = 2 |  0x5 << 12 | 0x3 << 8; // Use palette 2 dim 5+1x3+1 = 6x4 tiles
//
//   sprites[1].attributes	= 0xFF00; // Last sprite marker
//
//}

void drawHW() {
  setPalette(0, 2, &phelloworld);
//  setPalette(0, 2, &ryu);
  int i = 0;
  for (; i < helloworld.numTiles; i++) {
     Sprite* s = &sprites[i];
     GFXShapeTile* t = &(helloworld.tiles[i]);
     s->x = 196 + t->x * 16;
     s->y = 100 + t->y * 16;
     s->tile = t->id;
     s->attributes = 2 ;//|  0x5 << 1 | 0x3 << 1; // Use palette 2 dim 5+1x3+1 = 6x4 tiles
  }
  sprites[i].attributes	= 0xFF00; // Last sprite marker
}

void onVSync() {
//    drawRyu();
   drawHW();
   cpsa_reg[CPSA_REG_SPRITES_BASE] = (WORD)(((DWORD)sprites) >> 8);

   if (vsyncCounter == 0) {
   	*((char*)0x800180) = 1;///(0x22 + soundCounter);

   } else {
   	*((char*)0x800180) = 0xFF;
   }
   vsyncCounter++;
}

int run() {
	return 0;
}