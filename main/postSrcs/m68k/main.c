#include "ccps_gfx.h" // Contains all GFX data structures
#include "gfx.h" // This is auto-generated by GFX assets
#include "cpsa.h" // This is auto-generated
#include "cpsb.h" // This is auto-gemerated

// https://gcc.gnu.org/onlinedocs/gcc-3.2/gcc/Variable-Attributes.html
// https://ftp.gnu.org/old-gnu/Manuals/ld-2.9.1/html_chapter/ld_3.html
// https://mcuoneclipse.com/2016/11/01/getting-the-memory-range-of-sections-with-gnu-linker-files/

#define GFXRAM   __attribute__ ((section (".gfx_data")))

#define CPSA_REG __attribute__ ((section (".cpsa_reg")))  
#define CPSB_REG __attribute__ ((section (".cpsb_reg")))  


#define	MAXSPRITES	256
typedef struct {
	WORD	x;			// Sprite x position
	WORD	y;			// Sprite y position
	WORD	tile;		// Sprite tile

   // 0..4 CB[0..4] Palette ID used to render the tile
   // 5 X Flip Mirrored horizontally
   // 6 Y Flip Mirrored vertically
   // 7 LOOKUP Looks up the CB value into the RAM for each tile (see later section)
   // 8..11 XB[0..3] Horizontal size in tiles
   // 12..15 YB[0..3] Vertical size in tiles
	WORD	attributes;   	// Sprite attribute
} Sprite;

// TODO __attribute__ ((aligned (0xFF))) ?
GFXRAM Sprite sprites [MAXSPRITES]  =  {};


// TODO allow multpiple pages, right now there is only
//      enough space for one page (we need 6 for obj, scr1,2,3, and star1,2)
// TODO __attribute__ ((aligned ( 0x400))) ?
GFXRAM Palette palettes[32];

CPSA_REG WORD cpsa_reg[0x20] = {};
CPSB_REG WORD cpsb_reg[0x20] = {};


void setPalette(int page, int paletteID, const Palette* palette) {

   for (int j = 0 ; j < 16 ; j++) {
  	  palettes[paletteID].colors[j] = (*palette).colors[j];
   }

   // Request upload palette page to sprites
   cpsb_reg[CPSB_REG_PALETTE_CONTROL] =  1;

   // Set palette base
   cpsa_reg[CPSA_REG_PALETTE_BASE] = (WORD)(((DWORD)palettes) >> 8);
}

static const Palette p = <PALETTE>;
void draw() {
   setPalette(0, 2, &p); // Upload palette to Palette 2
   Sprite* s = &sprites[0];
   s->x = 220;
   s->y = 100;
   s->tile = <TILE>;
   s->attributes = 2 |  <TILE_HEIGHT> << 12 | <TILE_WIDTH> << 8; // user Palette 2 since it is where we placed it.

   sprites[1].attributes	= 0xFF00; // Last sprite marker

}

unsigned int vsyncCounter = 0;
unsigned int soundID = 0;
void onVSync() {
    draw();
   cpsa_reg[CPSA_REG_SPRITES_BASE] = (WORD)(((DWORD)sprites) >> 8);

   if (vsyncCounter > 60) {
   	*((char*)0x800180) = (45 + soundID);
   	soundID++;
    vsyncCounter = 0;
   } else {
   	*((char*)0x800180) = 0xFF;
   }
   vsyncCounter++;
}

int run() {
	return 0;
}