#include "ccps_gfx.h" // Contains all GFX data structures
#include "gfx.h" // This is auto-generated by GFX assets
#include "cpsa.h" // This is auto-generated
#include "cpsb.h" // This is auto-gemerated

// https://gcc.gnu.org/onlinedocs/gcc-3.2/gcc/Variable-Attributes.html
// https://ftp.gnu.org/old-gnu/Manuals/ld-2.9.1/html_chapter/ld_3.html
// https://mcuoneclipse.com/2016/11/01/getting-the-memory-range-of-sections-with-gnu-linker-files/

#define GFXRAM   __attribute__ ((section (".gfx_data")))

#define CPSA_REG __attribute__ ((section (".cpsa_reg")))  
#define CPSB_REG __attribute__ ((section (".cpsb_reg")))  


#define	MAXSPRITES	256
typedef struct {
	WORD	x;			// Sprite x position
	WORD	y;			// Sprite y position
	WORD	tile;		// Sprite tile

	// 0..4 CB[0..4] Palette ID used to render the tile
   // 5 X Flip Mirrored horizontally
   // 6 Y Flip Mirrored vertically
   // 7 LOOKUP Looks up the CB value into the RAM for each tile (see later section)
   // 8..11 XB[0..3] Horizontal size in tiles
   // 12..15 YB[0..3] Vertical size in tiles
	WORD	attributes;   	// Sprite attribute
} Sprite;

// TODO __attribute__ ((aligned (0xFF))) ?
GFXRAM Sprite sprites [MAXSPRITES]  =  {};


// TODO allow multpiple pages, right now there is only
//      enough space for one page (we need 6 for obj, scr1,2,3, and star1,2)
// TODO __attribute__ ((aligned ( 0x400))) ?
GFXRAM Palette palettes[32];

CPSA_REG WORD cpsa_reg[0x20] = {};
CPSB_REG WORD cpsb_reg[0x20] = {};


unsigned int vsyncCounter = 0;

// Z80 Commands and latches, use 0x800181 for BYTE selection
#define Z80_CMD *((volatile BYTE*)0x800181)
#define sendZ80(cmd) Z80_CMD = cmd

// Z80 Commands
#define Z80_NO_OP 0xFF

void hardwareInit() {
    // Set Z80 latch to 0xFF so nothing will be executed
    sendZ80(Z80_NO_OP);

    cpsa_reg[CPSA_REG_SCROLL1_SCROLLX] = 0x0000;
    cpsa_reg[CPSA_REG_SCROLL1_SCROLLY] = 0x0000;
    // Initialize CPSA&CPSB registers to the memory locations
    // sprites starts at 0x900000 in the example, Base 1, 2, 3 and
    //  other point to 0x90c000, 0x904000, 0x908000 and 0x920000
    cpsa_reg[CPSA_REG_SPRITES_BASE] = (WORD)(((DWORD)sprites) >> 8);;
    cpsa_reg[CPSA_REG_SCROLL1_BASE] = 0x90c0;
    cpsa_reg[CPSA_REG_SCROLL2_BASE] = 0x9040;
    cpsa_reg[CPSA_REG_SCROLL3_BASE] = 0x9080;
    cpsa_reg[CPSA_REG_OTHER_BASE] = 0x9200;

    // The following two are taken from what sf2 uses
    cpsb_reg[CPSB_REG_CTRL] = 0x12c2;
    cpsa_reg[CPSA_REG_VIDEOCONTROL] = 0x003e;
    // This defines the size of the palette, 64 in this case.
    // We are using only one, and sending 1 would work
    cpsb_reg[CPSB_REG_PALETTE_CONTROL] = 0x003f;
    // This array starts after sprites in GFX RAM, tell CPSA where it is
    cpsa_reg[CPSA_REG_PALETTE_BASE] = (WORD)(((DWORD)palettes) >> 8);
}


void setPalette(int page, int paletteID, const Palette* palette) {

   for (int j = 0 ; j < 16 ; j++) {
  	  palettes[paletteID].colors[j] = (*palette).colors[j];
   }

   // Request upload palette page to sprites
   cpsb_reg[CPSB_REG_PALETTE_CONTROL] =  0x3f;

   // Set palette base
   cpsa_reg[CPSA_REG_PALETTE_BASE] = (WORD)(((DWORD)palettes) >> 8);
}

void draw() {
  setPalette(0, 2, &phelloworld);
  int i = 0;
  for (; i < helloworld.numTiles; i++) {
     Sprite* s = &sprites[i];
     GFXShapeTile* t = &(helloworld.tiles[i]);
     s->x = 196 + t->x * 16;
     s->y = 100 + t->y * 16;
     s->tile = t->id;
     s->attributes = 2 ;//|  0x7 << 1 | 0x3 << 1; // Use palette 2 dim 5+1x3+1 = 6x4 tiles
  }
  sprites[i].attributes	= 0xFF00; // Last sprite marker

}

int onVSync() {
  draw();
  // Tell CPS-A where the sprites are.
  cpsa_reg[CPSA_REG_SPRITES_BASE] = (WORD)(((DWORD)sprites) >> 8);

  // We wait until the 60 frame so that there isn't a race condition with the Z80
  // and it is ready for playback.
  if (vsyncCounter == 60) {
    sendZ80(1);
  }
  vsyncCounter++;
}

int run() {
	return 0;
}