#include "ccps_gfx.h" // Contains all GFX data structures
#include "gfx.h" // This is auto-generated by GFX assets
#include "cpsa.h" // This is auto-generated
#include "cpsb.h" // This is auto-gemerated

// https://gcc.gnu.org/onlinedocs/gcc-3.2/gcc/Variable-Attributes.html
// https://ftp.gnu.org/old-gnu/Manuals/ld-2.9.1/html_chapter/ld_3.html
// https://mcuoneclipse.com/2016/11/01/getting-the-memory-range-of-sections-with-gnu-linker-files/

#define GFXRAM   __attribute__ ((section (".gfx_data")))

#define CPSA_REG __attribute__ ((section (".cpsa_reg")))  
#define CPSB_REG __attribute__ ((section (".cpsb_reg")))  


#define	MAXSPRITES	256
typedef struct {
	WORD	x;			// Sprite x position
	WORD	y;			// Sprite y position
	WORD	tile;		// Sprite tile

   // 0..4 CB[0..4] Palette ID used to render the tile
   // 5 X Flip Mirrored horizontally
   // 6 Y Flip Mirrored vertically
   // 7 LOOKUP Looks up the CB value into the RAM for each tile (see later section)
   // 8..11 XB[0..3] Horizontal size in tiles
   // 12..15 YB[0..3] Vertical size in tiles
	WORD	attributes;   	// Sprite attribute
} Sprite;

// TODO __attribute__ ((aligned (0xFF))) ?
GFXRAM Sprite sprites [MAXSPRITES]  =  {};


// TODO allow multpiple pages, right now there is only
//      enough space for one page (we need 6 for obj, scr1,2,3, and star1,2)
// TODO __attribute__ ((aligned ( 0x400))) ?
GFXRAM Palette palettes[32];

CPSA_REG WORD cpsa_reg[0x20] = {};
CPSB_REG WORD cpsb_reg[0x20] = {};

// Z80 Commands and latches, use 0x800181 for BYTE selection
#define Z80_CMD *((volatile BYTE*)0x800181)
#define sendZ80(cmd) Z80_CMD = cmd

// Z80 Commands
#define Z80_NO_OP 0xFF

// Register initializations
void hardwareInit() {
    sendZ80(Z80_NO_OP);

    cpsa_reg[CPSA_REG_SCROLL1_SCROLLX] = 0x0000;
    cpsa_reg[CPSA_REG_SCROLL1_SCROLLY] = 0x0000;
    cpsa_reg[CPSA_REG_SPRITES_BASE] = (WORD)(((DWORD)sprites) >> 8);;
    cpsa_reg[CPSA_REG_SCROLL1_BASE] = 0x90c0;
    cpsa_reg[CPSA_REG_SCROLL2_BASE] = 0x9040;
    cpsa_reg[CPSA_REG_SCROLL3_BASE] = 0x9080;
    cpsa_reg[CPSA_REG_OTHER_BASE] = 0x9200;

    cpsb_reg[CPSB_REG_CTRL] = 0x12c2;
    cpsa_reg[CPSA_REG_VIDEOCONTROL] = 0x003e;
    cpsb_reg[CPSB_REG_PALETTE_CONTROL] = 0x003f;
    cpsa_reg[CPSA_REG_PALETTE_BASE] = (WORD)(((DWORD)palettes) >> 8);
}

void setPalette(int page, int paletteID, const Palette* palette) {

   for (int j = 0 ; j < 16 ; j++) {
  	  palettes[paletteID].colors[j] = (*palette).colors[j];
   }

   // Request upload palette page to sprites
   cpsb_reg[CPSB_REG_PALETTE_CONTROL] =  0x3f;

   // Set palette base
   cpsa_reg[CPSA_REG_PALETTE_BASE] = (WORD)(((DWORD)palettes) >> 8);
}

static const Palette p = {0xF111,0xFFD9,0xFFB9,0xFE97,0xFC86,0xF965,0xF643,0xFB00,0xFFFF,0xFEEC,0xFDCA,0xFBA8,0xFA87,0xF765,0xFF00,0x0000,};
void draw() {
   setPalette(0, 2, &p); // Upload palette to Palette 2
   Sprite* s = &sprites[0];
   s->x = 220;
   s->y = 100;
   s->tile = 4;
   s->attributes = 2 |  5 << 12 | 3 << 8; // user Palette 2 since it is where we placed it.

   sprites[1].attributes	= 0xFF00; // Last sprite marker

}

unsigned int vsyncCounter = 0;
unsigned int soundID = 0;
void onVSync() {
   draw();
   cpsa_reg[CPSA_REG_SPRITES_BASE] = (WORD)(((DWORD)sprites) >> 8);

   if (vsyncCounter > 60) {
   	sendZ80(45 + soundID);
   	soundID++;
    vsyncCounter = 0;
   } else {
   	sendZ80(Z80_NO_OP);
   }
   vsyncCounter++;
}

int run() {
	return 0;
}